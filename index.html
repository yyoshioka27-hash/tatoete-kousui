<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#ffffff" />
  <link rel="manifest" href="./manifest.webmanifest" />
  <title>たとえて降水確率</title>
  <style>
    body { font-family: -apple-system, system-ui; margin: 0; padding: 20px; }
    .card { border: 1px solid #ddd; border-radius: 16px; padding: 16px; margin: 12px 0; }
    .big { font-size: 40px; font-weight: 700; }
    .small { color: #666; font-size: 13px; }
    button { padding: 12px 14px; border-radius: 12px; border: 1px solid #ddd; background: #fff; cursor: pointer; }
    input, select { padding: 12px 14px; border-radius: 12px; border: 1px solid #ddd; width: 100%; box-sizing: border-box; }
    label { margin-right: 12px; }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 10px; }
    .muted { color:#888; font-size:12px; }
    .ok { color:#0a7; font-size:12px; }
    .ng { color:#c33; font-size:12px; }
    .pill { display:inline-block; padding: 6px 10px; border: 1px solid #ddd; border-radius: 999px; font-size:12px; margin-right: 6px; }
    .slot { border: 1px solid #eee; border-radius: 14px; padding: 12px; margin-top: 10px; }
    .slot .big { font-size: 34px; }
    .slot .small { margin-top: 6px; }

    /* 例え文（朝・昼・夜）を読みやすく */
    #meta_m, #meta_d, #meta_e {
      font-size: 18px;
      color: #333;
      line-height: 1.6;
      font-weight: 500;
    }

    /* 人間向け翻訳（メイン）を大きく（PC向け） */
    #metaphor {
      font-size: 26px;
      line-height: 1.7;
    }

    /* =========================
       スマホ対応（画面幅 600px 以下）
       ========================= */
    @media (max-width: 600px) {

      body { padding: 12px; }

      h1 {
        font-size: 22px;
        margin: 0 0 12px;
      }

      .card {
        padding: 12px;
        margin: 10px 0;
      }

      /* 入力欄・ボタンを指で押しやすく */
      input, select, button {
        font-size: 16px;
        padding: 10px 12px;
      }

      .row {
        grid-template-columns: 1fr;
      }

      button#search {
        width: 100%;
      }

      /* %（朝・昼・夜） */
      .slot .big { font-size: 28px; }

      /* 朝・昼・夜の例え文 */
      #meta_m, #meta_d, #meta_e {
        font-size: 15px;
        line-height: 1.55;
      }

      /* 人間向け翻訳（メイン） */
      #metaphor {
        font-size: 20px;
        line-height: 1.6;
      }

      /* ピル（API / TZ 表示） */
      .pill {
        font-size: 11px;
        padding: 5px 8px;
      }
    }
  </style>
</head>
<body>
  <h1>たとえて降水確率</h1>

  <div class="card">
    <div class="small">天気予報を知りたい地点</div>
    <div class="row" style="margin-top:8px;">
      <input id="place" placeholder="例：仙台市 / Sendai / 仙台駅 / 仙台市青葉区" />
      <button id="search">検索</button>
    </div>
    <div style="margin-top:10px;">
      <select id="candidates" disabled>
        <option>検索結果がここに出ます</option>
      </select>
      <div id="placeStatus" class="muted" style="margin-top:8px;">地点を入力して「検索」してください（APIキー不要）</div>
    </div>
  </div>

  <div class="card">
    <div class="small">例えモード</div>
    <div style="margin-top:8px;">
      <label><input type="radio" name="mode" value="serious" checked> 真面目</label>
      <label><input type="radio" name="mode" value="trivia"> 雑学</label>
      <label><input type="radio" name="mode" value="fun"> お笑い</label>
    </div>
    <div class="muted" style="margin-top:8px;">※同じ確率でも、毎回ちがう例えが出ます</div>
  </div>

  <div class="card">
    <div class="small">今日の降水確率（朝/昼/夜）</div>
    <div class="small" id="popHint">地点を選ぶと自動取得します</div>

    <div class="slot">
      <div class="small">朝（6–11時）</div>
      <div class="big" id="pop_m">--%</div>
      <div class="small" id="meta_m"></div>
    </div>

    <div class="slot">
      <div class="small">昼（12–17時）</div>
      <div class="big" id="pop_d">--%</div>
      <div class="small" id="meta_d"></div>
    </div>

    <div class="slot">
      <div class="small">夜（18–23時）</div>
      <div class="big" id="pop_e">--%</div>
      <div class="small" id="meta_e"></div>
    </div>

    <div style="margin-top:10px;">
      <span class="pill" id="sourceTag">API: 未接続</span>
      <span class="pill" id="tzTag">TZ: --</span>
    </div>
  </div>

  <div class="card">
    <div class="small">人間向け翻訳（毎回ランダム）</div>
    <div class="big" id="metaphor">地点を選んでください</div>
    <div class="muted" id="metaFoot" style="margin-top:10px;"></div>
  </div>

  <button id="refresh">同じ確率でも例えを変える</button>

  <!-- 外部の例えデータを読み込み -->
  <script src="metaphors.js"></script>

  <script>

    // =========================
    // 天気取得：Open-Meteo
    // =========================
    const GEO = "https://geocoding-api.open-meteo.com/v1/search";
    const FC  = "https://api.open-meteo.com/v1/forecast";

    let state = {
      pops: null,         // { m: number|null, d: number|null, e: number|null }
      placeLabel: null,
      tz: null,
      source: "API: 未接続",
    };
    // 前回選んだ例え文を記憶しておき、連続同じメッセージが出ないようにする
    const lastMetaphor = {};
    // randomFact は metaphors.js で定義されています

    function pickRandom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function getMode() {
      return document.querySelector('input[name="mode"]:checked').value;
    }

    function metaphorFor(pop, mode) {
      const ranges = metaphorDB[mode] || [];
      const r = ranges.find(x => pop >= x.min && pop <= x.max) || ranges[ranges.length - 1];
      let picked = pickRandom(r.texts);
      // 同じモードと範囲で連続して同じテキストが選ばれないようにする
      if (r.texts && r.texts.length > 1) {
        const key = `${mode}:${r.min}-${r.max}`;
        let attempts = 0;
        while (picked === lastMetaphor[key] && attempts < 5) {
          picked = pickRandom(r.texts);
          attempts++;
        }
        lastMetaphor[key] = picked;
      }
      return (typeof picked === "function") ? picked() : picked;
    }

    function setStatus(text, kind="muted") {
      const el = document.getElementById("placeStatus");
      el.className = kind;
      el.textContent = text;
    }

    // ★ 日本語地名を少しでもヒットしやすくする前処理
    function normalizePlaceName(input) {
      return input
        .replace(/[ 　]+/g, " ")
        .replace(/(都|道|府|県|市|区|町|村)$/g, "")   // 末尾の行政単位を落とす
        .replace(/(都|道|府|県|市|区|町|村)/g, "")     // 途中も軽く落とす（仙台市青葉区 → 仙台青葉）
        .trim();
    }

    function render() {
      const hintEl = document.getElementById("popHint");
      const sourceTag = document.getElementById("sourceTag");
      const tzTag = document.getElementById("tzTag");

      const metaAll = document.getElementById("metaphor");
      const footEl = document.getElementById("metaFoot");

      sourceTag.textContent = state.source;
      tzTag.textContent = state.tz ? `TZ: ${state.tz}` : "TZ: --";

      const mode = getMode();

      const setSlot = (idPop, idMeta, value, label) => {
        const popEl = document.getElementById(idPop);
        const metaEl = document.getElementById(idMeta);

        if (value == null) {
          popEl.textContent = "--%";
          metaEl.textContent = "データなし";
          return null;
        }

        popEl.textContent = `${value}%`;
        const text = metaphorFor(value, mode);
        metaEl.textContent = `${label}：${text}`;
        return { value, text, label };
      };

      if (!state.pops) {
        hintEl.textContent = "地点を選ぶと自動取得します";
        setSlot("pop_m", "meta_m", null, "朝");
        setSlot("pop_d", "meta_d", null, "昼");
        setSlot("pop_e", "meta_e", null, "夜");
        metaAll.textContent = "地点を選んでください";
        footEl.textContent = "";
        return;
      }

      hintEl.textContent = state.placeLabel ? `地点：${state.placeLabel}` : "地点：--";

      const a = setSlot("pop_m", "meta_m", state.pops.m, "朝");
      const b = setSlot("pop_d", "meta_d", state.pops.d, "昼");
      const c = setSlot("pop_e", "meta_e", state.pops.e, "夜");

      const candidates = [a, b, c].filter(Boolean);
      if (!candidates.length) {
        metaAll.textContent = "データが取得できませんでした（別地点で試してください）";
      } else {
        const maxOne = candidates.reduce((x, y) => (y.value > x.value ? y : x));
        metaAll.textContent = `今日いちばん怪しいのは【${maxOne.label}】：${maxOne.value}% → ${maxOne.text}`;
      }

      if (mode === "serious") {
        footEl.textContent = "※真面目モード：統計ネタ等を混ぜた“ためになる例え”をランダム表示";
      } else if (mode === "trivia" || mode === "normal") {
        footEl.textContent = "※雑学モード：日常会話の温度感でランダム表示";
      } else {
        footEl.textContent = "※お笑いモード：SNS向けに遊んだ例えをランダム表示";
      }
    }

    async function geocode(name) {
      const url = new URL(GEO);
      url.searchParams.set("name", name);
      url.searchParams.set("count", "10");
      url.searchParams.set("language", "ja");
      url.searchParams.set("format", "json");
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("地点検索に失敗しました");
      return await res.json();
    }

    async function fetchPopsBySlots(lat, lon) {
      const url = new URL(FC);
      url.searchParams.set("latitude", String(lat));
      url.searchParams.set("longitude", String(lon));
      url.searchParams.set("hourly", "precipitation_probability");
      url.searchParams.set("timezone", "auto");
      url.searchParams.set("forecast_days", "2");

      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("天気取得に失敗しました");
      const data = await res.json();

      const times = data.hourly?.time || [];
      const pops  = data.hourly?.precipitation_probability || [];
      const tz    = data.timezone || null;

      const today = (times[0] || "").slice(0, 10);
      const bucket = { m: [], d: [], e: [] };

      for (let i = 0; i < Math.min(times.length, pops.length); i++) {
        const t = times[i];
        const p = pops[i];
        if (typeof p !== "number") continue;
        if (!t || t.slice(0, 10) !== today) continue;

        const hour = Number(t.slice(11, 13));
        if (hour >= 6 && hour <= 11) bucket.m.push(p);
        else if (hour >= 12 && hour <= 17) bucket.d.push(p);
        else if (hour >= 18 && hour <= 23) bucket.e.push(p);
      }

      const maxOrNull = (arr) => arr.length ? Math.round(Math.max(...arr)) : null;

      return {
        pops: {
          m: maxOrNull(bucket.m),
          d: maxOrNull(bucket.d),
          e: maxOrNull(bucket.e),
        },
        tz
      };
    }

    // UI: 検索→候補表示
    document.getElementById("search").onclick = async () => {
      const raw = document.getElementById("place").value.trim();
      const q = normalizePlaceName(raw);

      const sel = document.getElementById("candidates");
      sel.innerHTML = "";
      sel.disabled = true;

      if (!q) {
        setStatus("地点名を入力してください", "ng");
        return;
      }

      setStatus("検索中…", "muted");

      try {
        // まず正規化した文字列で検索
        let g = await geocode(q);
        let results = g.results || [];

        // もしダメなら、生入力でも一度試す（保険）
        if (!results.length && raw !== q) {
          g = await geocode(raw);
          results = g.results || [];
        }

        if (!results.length) {
          setStatus("候補が見つかりませんでした。別の書き方で試してください。（例：Sendai）", "ng");
          return;
        }

        results.forEach((r, idx) => {
          const labelParts = [r.name, r.admin1, r.country].filter(Boolean);
          const label = labelParts.join(" / ");
          const opt = document.createElement("option");
          opt.value = String(idx);
          opt.textContent = label;
          opt.dataset.lat = r.latitude;
          opt.dataset.lon = r.longitude;
          sel.appendChild(opt);
        });

        sel.disabled = false;
        setStatus("候補を選ぶと天気を取得します", "ok");

        sel.onchange = async () => {
          const opt = sel.options[sel.selectedIndex];
          const lat = Number(opt.dataset.lat);
          const lon = Number(opt.dataset.lon);

          state.placeLabel = opt.textContent;
          state.source = "API: Open-Meteo";
          render();
          setStatus("天気取得中…", "muted");

          try {
            const out = await fetchPopsBySlots(lat, lon);
            state.pops = out.pops;
            state.tz = out.tz;

            const any = (state.pops.m != null) || (state.pops.d != null) || (state.pops.e != null);
            if (!any) {
              setStatus("降水確率が取得できませんでした（別地点で試してください）", "ng");
              state.source = "API: 取得失敗";
              state.pops = null;
            } else {
              setStatus("取得しました", "ok");
            }

            render();
          } catch (e) {
            setStatus(e.message || "天気取得エラー", "ng");
            state.source = "API: エラー";
            state.pops = null;
            render();
          }
        };

        // 自動で1件目を選択して即取得
        sel.selectedIndex = 0;
        sel.onchange();

      } catch (e) {
        setStatus(e.message || "検索エラー", "ng");
      }
    };

    // モード変更で例え更新（同じ確率でもランダムが変わる）
    document.querySelectorAll('input[name="mode"]').forEach(r =>
      r.addEventListener("change", render)
    );

    // 「同じ確率でも例えを変える」ボタン（確率はそのまま、文章だけランダム更新）
    document.getElementById("refresh").onclick = () => render();

    // Service Worker登録（PWA）
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./sw.js", { scope: "./" });
    }

    render();
  </script>
</body>
</html>
